import{p as g,J as h,f as v,K as u,r as m,v as b,i as l,w as d,h as r}from"../chunks/D9dWO0Sc.js";import{_ as B}from"../chunks/COEqP30R.js";var w=v('<div style="width: 100%; height: 400px;" class="svelte-148407r"><canvas></canvas></div>');function x(o,t){g(t,!0);let s;const c={labels:["1 Estimator","2 Estimators","5 Estimators","10 Estimators","20 Estimators"],datasets:[{label:"Variance",data:[1,.5,.2,.1,.05],borderColor:"blue",fill:!1,tension:.1}]};h(async()=>{const n=(await B(async()=>{const{default:a}=await import("../chunks/D9dWO0Sc.js").then(e=>e.ac);return{default:a}},[],import.meta.url)).default;new n(s,{type:"line",data:c,options:{responsive:!0,maintainAspectRatio:!1,plugins:{title:{display:!0,text:"Variance Reduction by Averaging Estimators"}},scales:{y:{beginAtZero:!0,title:{display:!0,text:"Variance"}},x:{title:{display:!0,text:"Number of Estimators Averaged"}}}}})});var i=w(),p=l(i);u(p,n=>s=n,()=>s),d(i),m(o,i),b()}var z=v('<div class="bootstrap-diagram svelte-qzrp5z"><h3>Bootstrap Sampling Process</h3> <div class="step svelte-qzrp5z"><div class="box svelte-qzrp5z">Original Dataset (D)</div> <div class="arrow svelte-qzrp5z">↓</div></div> <div class="step svelte-qzrp5z"><div class="box svelte-qzrp5z">Random Sampling with Replacement (n times)</div> <div class="arrow svelte-qzrp5z">↓</div></div> <div class="step-group svelte-qzrp5z"><div class="step-item svelte-qzrp5z"><div class="box svelte-qzrp5z">Bootstrap Sample 1 (D*1)</div></div> <div class="step-item svelte-qzrp5z"><div class="box svelte-qzrp5z">Bootstrap Sample 2 (D*2)</div></div> <div class="step-item svelte-qzrp5z"><div class="box svelte-qzrp5z">...</div></div> <div class="step-item svelte-qzrp5z"><div class="box svelte-qzrp5z">Bootstrap Sample B (D*B)</div></div></div> <p class="note svelte-qzrp5z">Each bootstrap sample has the same size as the original dataset, with some elements repeated and some omitted.</p></div>');function D(o){var t=z();m(o,t)}var _=v('<div class="flowchart-container svelte-19yltjp"><h3>Bagging Process Flowchart</h3> <div class="node svelte-19yltjp">Original Dataset</div> <div class="arrow svelte-19yltjp">↓</div> <div class="node svelte-19yltjp">Generate B Bootstrap Samples</div> <div class="arrow svelte-19yltjp">↓</div> <div class="parallel-process svelte-19yltjp"><div class="process-item svelte-19yltjp"><div class="node svelte-19yltjp">Train Model 1 on Bootstrap Sample 1</div></div> <div class="process-item svelte-19yltjp"><div class="node svelte-19yltjp">Train Model 2 on Bootstrap Sample 2</div></div> <div class="process-item svelte-19yltjp"><div class="node svelte-19yltjp">...</div></div> <div class="process-item svelte-19yltjp"><div class="node svelte-19yltjp">Train Model B on Bootstrap Sample B</div></div></div> <div class="arrow svelte-19yltjp">↓</div> <div class="node svelte-19yltjp">Combine Predictions (e.g., Averaging/Majority Vote)</div> <div class="arrow svelte-19yltjp">↓</div> <div class="node final svelte-19yltjp">Bagged Prediction</div></div>');function R(o){var t=_();m(o,t)}var Z=v('<div style="width: 100%; height: 400px;" class="svelte-148407r"><canvas></canvas></div>');function E(o,t){g(t,!0);let s;const c={labels:["m=1","m=sqrt(p)","m=p/2","m=p"],datasets:[{label:"Error Rate (Simulated)",data:[.25,.1,.12,.18],backgroundColor:["#ff6384","#36a2eb","#cc65fe","#ffce56"],borderColor:"rgba(0,0,0,0)",borderWidth:1}]};h(async()=>{const n=(await B(async()=>{const{default:a}=await import("../chunks/D9dWO0Sc.js").then(e=>e.ac);return{default:a}},[],import.meta.url)).default;new n(s,{type:"bar",data:c,options:{responsive:!0,maintainAspectRatio:!1,plugins:{title:{display:!0,text:"Impact of Feature Subset Size (m) on Random Forest Error Rate"},tooltip:{callbacks:{title(a){const e=a[0].label;return e==="m=sqrt(p)"?"Optimal m (typically)":e},label(a){let e=a.dataset.label||"";return e&&(e+=": "),e+=a.raw+"%",e}}}},scales:{y:{beginAtZero:!0,title:{display:!0,text:"Error Rate"}},x:{title:{display:!0,text:"Feature Subset Size (m)"}}}}})});var i=Z(),p=l(i);u(p,n=>s=n,()=>s),d(i),m(o,i),b()}var S=v(`<div class="article-container svelte-1asapdf"><h1 class="svelte-1asapdf">Bagging and Random Forests</h1> <p class="svelte-1asapdf">This article explores the concepts of Bagging and Random Forests, powerful ensemble learning techniques used in machine learning to improve prediction accuracy and reduce overfitting. We will delve into the benefits of averaging, the role of bootstrapping, and how Random Forests enhance Bagging by decorrelating trees.</p> <h2 class="svelte-1asapdf">The Benefits of Averaging</h2> <p class="svelte-1asapdf">A Lousy Estimator Let Z,Z1,...,Zn i.i.d. EZ = µ and VarZ = σ2. We could use any single Zi to estimate µ. Performance? Unbiased: EZi = µ. Standard error of estimator would be σ. The standard error is the standard deviation of the sampling distribution of a statistic. SD(Z) = pVar(Z) = √ σ2 = σ.
  Variance of a Mean Let Z,Z1,...,Zn i.i.d. EZ = µ and VarZ = σ2. Let's consider the average of the Zi 's. Average has the same expected value but smaller standard error: E " 1 n n X i=1 Zi # = µ Var " 1 n n X i=1 Zi # = σ2 n . Clearly the average is preferred to a single Zi as estimator. Can we apply this to reduce variance of general decision functions?
  Averaging Independent Prediction Functions Suppose we have B independent training sets from the same distribution. Learning algorithm gives B decision functions: f1(x), f2(x),...,fB(x) Define the average prediction function as: f avg = 1 B B X b=1 f b What's random here?
  Averaging Independent Prediction Functions Fix some x ∈ X. Then average prediction on x is f avg(x) = 1 B B X b=1 f b(x). Consider favg(x) and f 1(x),...,fB(x) as random variables (since training data random). f 1(x),...,fB(x) are i.i.d. f avg(x) and f b(x) have the same expected value, but f avg(x) has smaller variance: Var(favg(x)) = 1 B Var f 1(x)
  Averaging Independent Prediction Functions Using f avg = 1 B B X b=1 f b seems like a win. But in practice we don't have B independent training sets... Instead, we can use the bootstrap....</p> <div class="visualization-section svelte-1asapdf"><h3 class="svelte-1asapdf">Visualization: Variance Reduction by Averaging Estimators</h3> <!></div> <h2 class="svelte-1asapdf">Review: Bootstrap</h2> <p class="svelte-1asapdf">The Bootstrap Sample Definition A bootstrap sample from Dn is a sample of size n drawn with replacement from Dn. In a bootstrap sample, some elements of Dn will show up multiple times, some won't show up at all. Each Xi has a probability (1-1/n)n of not being selected. Recall from analysis that for large n, 1- 1 n n ≈ 1 e ≈ .368. So we expect ~63.2% of elements of D will show up at least once.
  The Bootstrap Method Definition A bootstrap method is when you simulate having B independent samples from P by taking B bootstrap samples from the sample Dn. Given original data Dn, compute B bootstrap samples D1 n,...,DB n . For each bootstrap sample, compute some function φ(D1 n),...,φ(DB n ) Work with these values as though D1 n,...,DB n were i.i.d. P. Amazing fact: Things often come out very close to what we'd get with independent samples from P.</p> <div class="visualization-section svelte-1asapdf"><h3 class="svelte-1asapdf">Visualization: Bootstrap Sampling Process</h3> <!></div> <h2 class="svelte-1asapdf">Bagging</h2> <p class="svelte-1asapdf"></p> <div class="visualization-section svelte-1asapdf"><h3 class="svelte-1asapdf">Visualization: Bagging Process Flowchart</h3> <!></div> <h2 class="svelte-1asapdf">Random Forests</h2> <p class="svelte-1asapdf">Recall the Motivating Principal of Bagging Averaging f1,...,fB reduces variance, if they're based on i.i.d. samples from PX×Y Bootstrap samples are independent samples from the training set, but are not indepedendent samples from PX×Y. This dependence limits the amount of variance reduction we can get. Would be nice to reduce the dependence between fi 's...
  Variance of a Mean of Correlated Variables For Z,Z1,...,Zn i.i.d. with EZ = µ and VarZ = σ2, E " 1 n n X i=1 Zi # = µ Var " 1 n n X i=1 Zi # = σ2 n . What if Z's are correlated? Suppose ∀i 6= j, Corr(Zi ,Zj ) = ρ . Then Var " 1 n n X i=1 Zi # = ρσ2 + 1-ρ n σ2. For large n, the ρσ2 term dominates – limits benefit of averaging.
  Random Forest Main idea of random forests Use bagged decision trees, but modify the tree-growing procedure to reduce the correlation between trees. Key step in random forests: When constructing each tree node, restrict choice of splitting variable to a randomly chosen subset of features of size m. Typically choose m ≈ √ p, where p is the number of features. Can choose m using cross validation.
  Random Forest: Effect of m size</p> <div class="visualization-section svelte-1asapdf"><h3 class="svelte-1asapdf">Visualization: Impact of Feature Subset Size (m) on Random Forest Error Rate</h3> <!></div></div>`);function C(o){var t=S(),s=r(l(t),8),c=r(l(s),2);x(c,{}),d(s);var i=r(s,6),p=r(l(i),2);D(p),d(i);var n=r(i,4);n.textContent=`Bagging Draw B bootstrap samples D1,...,DB from original data D. Let f1, f2,...,fB be the decision functions for each set. The bagged decision function is a combination of these: f avg(x) = Combine f 1(x), f2(x),...,fB(x) How might we combine decision functions for regression? binary class predictions? binary probability predictions? multiclass predictions? Bagging proposed by Leo Breiman (1996).
  Bagging for Regression Draw B bootstrap samples D1,...,DB from original data D. Let f1, f2,...,fB : X → R be the predictions functions for each set. Bagged prediction function is given as f bag(x) = 1 B B X b=1 f b(x). Empirically, fbag often performs similarly to what we'd get from training on B independent samples: f bag(x) has same expectation as f1(x), but f bag(x) has smaller variance than f1(x)
  Out-of-Bag Error Estimation Each bagged predictor is trained on about 63% of the data. Remaining 37% are called out-of-bag (OOB) observations. For ith training point, let Si = b | Db does not contain ith point . The OOB prediction on xi is f OOB(xi ) = 1 |Si | X b∈Si f b(x). The OOB error is a good estimate of the test error. OOB error is similar to cross validation error – both are computed on training set.
  Bagging Classification Trees Input space X = R5 and output space Y = 1. Sample size N = 30 (simulated data)
  Comparing Classification Combination Methods Two ways to combine classifications: consensus class or average probabilities.
  Terms “Bias” and “Variance” in Casual Usage (Warning! Confusion Zone!) Restricting the hypothesis space F “biases” the fit towards a simpler model and away from the best possible fit of the training data. Full, unpruned decision trees have very little bias. Pruning decision trees introduces a bias. Variance describes how much the fit changes across different random training sets. If different random training sets give very similar fits, then algorithm has high stability. Decision trees are found to be high variance (i.e. not very stable).
  Conventional Wisdom on When Bagging Helps Hope is that bagging reduces variance without making bias worse. General sentiment is that bagging helps most when Relatively unbiased base prediction functions High variance / low stability i.e. small changes in training set can cause large changes in predictions Hard to find clear and convinving theoretical results on this But following this intuition leads to improved ML methods, e.g. Random Forests`;var a=r(n,2),e=r(l(a),2);R(e),d(a);var f=r(a,6),y=r(l(f),2);E(y,{}),d(f),d(t),m(o,t)}export{C as component};
