import type {
    ProcessedDocument,
    KnowledgeNode,
    ContentRelationship,
    NodeMetadata,
    InteractiveArticle
} from '$lib/types/unified';
import { relationshipDetectionService, type RelationshipDetectionResult } from './relationshipDetectionService.js';
import { logger } from '../utils/logger.js';

export interface NodeCreationOptions {
    autoCreateRelationships?: boolean;
    minRelationshipConfidence?: number;
    generateTags?: boolean;
    extractCategories?: boolean;
    assignToCollections?: boolean;
}

export interface IntegrationResult {
    node: KnowledgeNode;
    relationships: ContentRelationship[];
    suggestions: RelationshipDetectionResult;
    metadata: NodeCreationMetadata;
}

export interface NodeCreationMetadata {
    createdAt: Date;
    source: 'document' | 'url' | 'manual';
    processingTime: number;
    confidence: number;
    autoGeneratedFields: string[];
}

/**
 * Service for integrating transformed documents into the knowledge base
 */
export class KnowledgeBaseIntegrationService {
    private readonly defaultOptions: Required<NodeCreationOptions> = {
        autoCreateRelationships: true,
        minRelationshipConfidence: 0.4,
        generateTags: true,
        extractCategories: true,
        assignToCollections: true
    };

    /**
     * Integrate a processed document into the knowledge base
     */
    async integrateDocument(
        document: ProcessedDocument,
        existingNodes: KnowledgeNode[],
        options: NodeCreationOptions = {}
    ): Promise<IntegrationResult> {
        const startTime = Date.now();
        const opts = { ...this.defaultOptions, ...options };

        try {
            logger.info('Starting knowledge base integration', {
                documentId: document.id,
                title: document.title
            });

            // Create the knowledge node
            const node = await this.createKnowledgeNode(document, opts);

            // Analyze relationships with existing nodes
            const relationshipResult = await relationshipDetectionService.analyzeContentRelationships(
                document,
                existingNodes,
                {
                    minConfidence: opts.minRelationshipConfidence,
                    analysisDepth: 'medium'
                }
            );

            // Create relationships if auto-creation is enabled
            const relationships: ContentRelationship[] = [];
            if (opts.autoCreateRelationships) {
                relationships.push(...relationshipResult.relationships);
            }

            const processingTime = Date.now() - startTime;
            const metadata: NodeCreationMetadata = {
                createdAt: new Date(),
                source: this.determineDocumentSource(document),
                processingTime,
                confidence: relationshipResult.confidence,
                autoGeneratedFields: this.getAutoGeneratedFields(node, opts)
            };

            const result: IntegrationResult = {
                node,
                relationships,
                suggestions: relationshipResult,
                metadata
            };

            logger.info('Knowledge base integration completed', {
                nodeId: node.id,
                relationshipsCreated: relationships.length,
                suggestionsGenerated: relationshipResult.suggestedConnections.length,
                processingTime
            });

            return result;
        } catch (error) {
            logger.error('Failed to integrate document into knowledge base', {
                error,
                documentId: document.id
            });
            throw new Error(`Knowledge base integration failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Create a knowledge node from a processed document
     */
    private async createKnowledgeNode(
        document: ProcessedDocument,
        options: Required<NodeCreationOptions>
    ): Promise<KnowledgeNode> {
        const nodeMetadata = await this.generateNodeMetadata(document, options);

        const node: KnowledgeNode = {
            id: `node_${document.id}`,
            title: document.title,
            type: 'interactive-content',
            source: {
                type: this.determineDocumentSource(document),
                originalId: document.id,
                originalUrl: document.metadata.sourceUrl,
                importedAt: new Date()
            },
            content: document.content,
            relationships: [], // Will be populated separately
            prerequisites: [],
            dependents: [],
            status: 'available',
            interactivity: this.determineInteractivityLevel(document) as any,
            // Move temporal/version info into metadata per unified types
            metadata: {
                ...nodeMetadata,
                created: new Date(),
                modified: new Date(),
                version: 1
            }
        };

        return node;
    }

    /**
     * Generate comprehensive metadata for the knowledge node
     */
    private async generateNodeMetadata(
        document: ProcessedDocument,
        options: Required<NodeCreationOptions>
    ): Promise<NodeMetadata> {
        const metadata: NodeMetadata = {
            description: this.generateDescription(document),
            author: document.metadata.author,
            created: new Date(),
            modified: new Date(),
            version: 1,
            wordCount: this.calculateWordCount(document),
            readingTime: this.estimateReadingTime(document),
            difficulty: this.assessDifficulty(document),
            completionStatus: 'draft',
            tags: [],
            estimatedTime: this.estimateReadingTime(document)
        };

        if (options.generateTags) {
            metadata.tags = await this.generateTags(document);
        }

        if (options.extractCategories) {
            metadata.categories = await this.extractCategories(document);
        }

        if (options.assignToCollections) {
            metadata.collections = await this.suggestCollections(document);
        }

        return metadata;
    }

    /**
     * Generate a description for the document
     */
    private generateDescription(document: ProcessedDocument): string {
        const textContent = document.content
            .filter(block => block.type === 'text')
            .map(block => typeof block.content === 'string' ? block.content : '')
            .join(' ');

        // Extract first meaningful paragraph or create from title
        const sentences = textContent.split(/[.!?]+/).filter(s => s.trim().length > 20);
        if (sentences.length > 0) {
            return sentences[0].trim().substring(0, 200) + (sentences[0].length > 200 ? '...' : '');
        }

        return `Interactive content based on: ${document.title}`;
    }

    /**
     * Calculate word count for the document
     */
    private calculateWordCount(document: ProcessedDocument): number {
        const textContent = document.content
            .filter(block => block.type === 'text')
            .map(block => typeof block.content === 'string' ? block.content : '')
            .join(' ');

        return textContent.split(/\s+/).filter(word => word.length > 0).length;
    }

    /**
     * Estimate reading time in minutes
     */
    private estimateReadingTime(document: ProcessedDocument): number {
        const wordCount = this.calculateWordCount(document);
        const wordsPerMinute = 200; // Average reading speed
        return Math.ceil(wordCount / wordsPerMinute);
    }

    /**
     * Assess content difficulty level
     */
    private assessDifficulty(document: ProcessedDocument): 'beginner' | 'intermediate' | 'advanced' {
        const wordCount = this.calculateWordCount(document);
        const hasCodeBlocks = document.content.some(block => block.type === 'code');
        const hasComplexStructure = document.structure.sections.length > 5;

        if (wordCount > 2000 || hasCodeBlocks || hasComplexStructure) {
            return 'advanced';
        } else if (wordCount > 800 || document.structure.sections.length > 3) {
            return 'intermediate';
        }
        return 'beginner';
    }

    /**
     * Generate tags for the document
     */
    private async generateTags(document: ProcessedDocument): Promise<string[]> {
        const tags: Set<string> = new Set();

        // Add tags based on content type
        document.content.forEach(block => {
            switch (block.type) {
                case 'code':
                    tags.add('programming');
                    tags.add('code');
                    break;
                case 'image':
                    tags.add('visual');
                    break;
                case 'video':
                    tags.add('multimedia');
                    break;
                case 'quiz':
                    tags.add('interactive');
                    tags.add('assessment');
                    break;
            }
        });

        // Add tags based on document structure
        if (document.structure.sections.length > 5) {
            tags.add('comprehensive');
        }

        // Add tags based on title keywords
        const titleWords = document.title.toLowerCase().split(/\s+/);
        titleWords.forEach(word => {
            if (word.length > 4 && !this.isCommonWord(word)) {
                tags.add(word);
            }
        });

        return Array.from(tags).slice(0, 10); // Limit to 10 tags
    }

    /**
     * Extract categories from document content
     */
    private async extractCategories(document: ProcessedDocument): Promise<string[]> {
        const categories: Set<string> = new Set();

        // Determine categories based on content analysis
        const textContent = document.content
            .filter(block => block.type === 'text')
            .map(block => typeof block.content === 'string' ? block.content : '')
            .join(' ')
            .toLowerCase();

        // Simple keyword-based categorization
        const categoryKeywords = {
            'technology': ['software', 'programming', 'code', 'development', 'tech', 'computer'],
            'science': ['research', 'study', 'analysis', 'experiment', 'data', 'theory'],
            'business': ['strategy', 'management', 'marketing', 'finance', 'company'],
            'education': ['learning', 'tutorial', 'guide', 'course', 'lesson', 'teaching'],
            'design': ['ui', 'ux', 'interface', 'visual', 'design', 'layout']
        };

        Object.entries(categoryKeywords).forEach(([category, keywords]) => {
            if (keywords.some(keyword => textContent.includes(keyword))) {
                categories.add(category);
            }
        });

        return Array.from(categories);
    }

    /**
     * Suggest collections for the document
     */
    private async suggestCollections(document: ProcessedDocument): Promise<string[]> {
        const collections: string[] = [];

        // Suggest collections based on document characteristics
        if (document.content.some(block => block.type === 'quiz')) {
            collections.push('Interactive Learning');
        }

        if (document.content.some(block => block.type === 'code')) {
            collections.push('Technical Documentation');
        }

        if (this.calculateWordCount(document) > 1500) {
            collections.push('In-Depth Articles');
        }

        if (document.structure.sections.length > 3) {
            collections.push('Comprehensive Guides');
        }

        return collections;
    }

    /**
     * Determine the source type of the document
     */
    private determineDocumentSource(document: ProcessedDocument): 'document' | 'url' | 'manual' {
        if (document.metadata.sourceUrl) {
            return 'url';
        }
        if (document.metadata.originalFileName) {
            return 'document';
        }
        return 'manual';
    }

    /**
     * Determine interactivity level of the document
     */
    private determineInteractivityLevel(document: ProcessedDocument): 'static' | 'basic' | 'advanced' {
        const interactiveBlocks = document.content.filter(block =>
            ['quiz', 'code', 'interactive-chart', 'expandable'].includes(block.type)
        );

        if (interactiveBlocks.length > 3) {
            return 'advanced';
        } else if (interactiveBlocks.length > 0) {
            return 'basic';
        }
        return 'static';
    }

    /**
     * Get list of auto-generated fields
     */
    private getAutoGeneratedFields(node: KnowledgeNode, options: Required<NodeCreationOptions>): string[] {
        const fields: string[] = ['description', 'wordCount', 'readingTime', 'difficulty'];

        if (options.generateTags) {fields.push('tags');}
        if (options.extractCategories) {fields.push('categories');}
        if (options.assignToCollections) {fields.push('collections');}

        return fields;
    }

    /**
     * Check if a word is a common word that shouldn't be used as a tag
     */
    private isCommonWord(word: string): boolean {
        const commonWords = new Set([
            'the', 'and', 'for', 'are', 'but', 'not', 'you', 'all', 'can', 'had', 'her', 'was', 'one', 'our', 'out', 'day', 'get', 'has', 'him', 'his', 'how', 'its', 'may', 'new', 'now', 'old', 'see', 'two', 'who', 'boy', 'did', 'man', 'men', 'put', 'say', 'she', 'too', 'use'
        ]);
        return commonWords.has(word.toLowerCase());
    }

    /**
     * Update an existing knowledge node with new relationships
     */
    async updateNodeRelationships(
        nodeId: string,
        newRelationships: ContentRelationship[]
    ): Promise<void> {
        try {
            logger.info('Updating node relationships', {
                nodeId,
                relationshipCount: newRelationships.length
            });

            // This would typically interact with your storage layer
            // For now, we'll just log the operation
            logger.info('Node relationships updated successfully', { nodeId });
        } catch (error) {
            logger.error('Failed to update node relationships', { error, nodeId });
            throw new Error(`Failed to update relationships: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }

    /**
     * Remove relationships for a node
     */
    async removeNodeRelationships(
        nodeId: string,
        relationshipIds: string[]
    ): Promise<void> {
        try {
            logger.info('Removing node relationships', {
                nodeId,
                relationshipIds
            });

            // This would typically interact with your storage layer
            logger.info('Node relationships removed successfully', { nodeId });
        } catch (error) {
            logger.error('Failed to remove node relationships', { error, nodeId });
            throw new Error(`Failed to remove relationships: ${error instanceof Error ? error.message : 'Unknown error'}`);
        }
    }
}

export const knowledgeBaseIntegrationService = new KnowledgeBaseIntegrationService();